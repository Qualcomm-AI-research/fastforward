#!/usr/bin/env python3

# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

"""Custom Mypy AST Traverser Implementation Generator.

This script generates a custom implementation of a traverser for Mypy's AST
nodes that can be used outside of mypy's compilation unit.

## Problem
Mypy provides a TraverserVisitor class that can be used to traverse its AST.
However, when using a compiled version of mypy (as installed via pip), this
class cannot be subclassed outside of mypy's compilation unit. Similarly, we
cannot subclass NodeVisitor from mypy for the same reason, which means that
Node.accept() will raise an error when we try to 'visit' the tree from external
code.

## Solution
1. We extract and include the original source code from TraverserVisitor in our codebase
2. We invert the Node.accept pattern into a visitor.visit structure, duplicating the logic
    but making it usable outside of mypy's compilation boundaries
3. We use a code generator to keep our implementation in sync with mypy's node definitions,
    ensuring compatibility when mypy's AST structure changes

This approach allows us to traverse and analyze mypy AST nodes from external code while
maintaining compatibility with future versions of mypy through the generation script.
"""

import argparse
import pathlib
import subprocess
import textwrap

from collections.abc import Sequence

import libcst
import libcst.helpers
import mypy

from fastforward._autoquant.pass_manager import PassManager


def main() -> None:
    """Script entry point."""
    parser = argparse.ArgumentParser()
    parser.add_argument("--output", default=None, help="output file")
    args = parser.parse_args()

    pm = PassManager([
        _StripModule(keep_names=["TraverserVisitor"]),
        _RemoveClassDecoratorsAndSuperClass(),
        _InvertAcceptCalls(),
        _InsertImports(imports=[_import_statement("import functools")]),
    ])
    module_cst = pm(libcst.parse_module(_mypy_traverser_file().read_text()))

    generated = _prefix_copyright_notice(_disable_lint_directives(module_cst.code))

    if args.output is not None:
        with open(args.output, "w") as f:
            f.write(generated)
            subprocess.run(
                ["ruff", "check", "--fix", args.output],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            subprocess.run(
                ["ruff", "format", args.output],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
    else:
        print(generated)


def _import_statement(src: str) -> libcst.Import | libcst.ImportFrom:
    stmt = libcst.parse_statement(src)
    assert isinstance(stmt, libcst.SimpleStatementLine)
    assert isinstance(import_statement := stmt.body[0], (libcst.Import, libcst.ImportFrom))
    return import_statement


def _mypy_traverser_file() -> pathlib.Path:
    return pathlib.Path(mypy.__file__).parent / "traverser.py"


def _disable_lint_directives(suffix: str) -> str:
    disable_directive = "# ruff: noqa: D102, ARG002, E741, D415, CPY001"
    return f"{disable_directive}\n\n{suffix}"


def _prefix_copyright_notice(suffix: str) -> str:
    prefix = """
    # NOTE: This file is automatically generated, do not edit.
    #
    # The code below is adapted from Mypy (mypy/traverser.py)
    #
    # The MIT License
    #
    # Copyright (c) 2012-2023 Jukka Lehtosalo and contributors
    # Copyright (c) 2015-2023 Dropbox, Inc.
    #
    # Permission is hereby granted, free of charge, to any person obtaining a
    # copy of this software and associated documentation files (the "Software"),
    # to deal in the Software without restriction, including without limitation
    # the rights to use, copy, modify, merge, publish, distribute, sublicense,
    # and/or sell copies of the Software, and to permit persons to whom the
    # Software is furnished to do so, subject to the following conditions:
    #
    # The above copyright notice and this permission notice shall be included in
    # all copies or substantial portions of the Software.
    #
    # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    # DEALINGS IN THE SOFTWARE.
    """.strip()
    return f"{prefix}\n\n{suffix}"


class _StripModule(libcst.CSTTransformer):
    """Transform a CST by removing all classes and functions except specified ones.

    This transformer visits the CST and removes all function definitions unconditionally,
    while preserving only those class definitions whose names are in the provided
    keep_names list. This is useful for extracting specific classes from a module
    while discarding all other definitions.

    Args:
        keep_names: A sequence of class names to preserve in the transformed CST.
               All other classes and all functions will be removed.
    """

    def __init__(self, keep_names: Sequence[str]) -> None:
        self._keep_names = set(keep_names)

    def visit_ClassDef(self, node: libcst.ClassDef) -> bool | None:
        del node
        return False

    def leave_ClassDef(
        self, original_node: libcst.ClassDef, updated_node: libcst.ClassDef
    ) -> (
        libcst.BaseStatement | libcst.FlattenSentinel[libcst.BaseStatement] | libcst.RemovalSentinel
    ):
        del original_node
        if updated_node.name.value in self._keep_names:
            return updated_node
        else:
            return libcst.RemovalSentinel.REMOVE

    def leave_FunctionDef(
        self, original_node: libcst.FunctionDef, updated_node: libcst.FunctionDef
    ) -> (
        libcst.BaseStatement | libcst.FlattenSentinel[libcst.BaseStatement] | libcst.RemovalSentinel
    ):
        del original_node, updated_node
        return libcst.RemovalSentinel.REMOVE


class _RemoveClassDecoratorsAndSuperClass(libcst.CSTTransformer):
    """Transform class definitions by removing decorators and base classes.

    This transformer visits class definitions in the CST and strips away all decorators
    and parent classes (bases). This is useful when adapting code from another codebase
    where we want to keep the class implementation but remove its inheritance hierarchy
    and any decorators that might not be available or applicable in our context.

    The transformation preserves all other aspects of the class definition including
    its name, body, and any other attributes.
    """

    def visit_ClassDef(self, node: libcst.ClassDef) -> bool | None:
        del node
        return False

    def leave_ClassDef(
        self, original_node: libcst.ClassDef, updated_node: libcst.ClassDef
    ) -> (
        libcst.BaseStatement | libcst.FlattenSentinel[libcst.BaseStatement] | libcst.RemovalSentinel
    ):
        del original_node
        return updated_node.with_changes(bases=(), decorators=())


class _InvertAcceptCalls(libcst.CSTTransformer):
    """Transform Mypy's accept-based visitor pattern to a dispatch-based visitor pattern.

    This transformer converts Mypy's Node.accept(visitor) pattern to a visitor.visit(node) pattern
    by:

    1. Adding a singledispatch-based _visit() function that dispatches based on node type
    2. Adding visit(), enter_node(), and leave_node() methods to the TraverserVisitor class
    3. Converting all node.accept(self) calls to _visit(node, self) calls
    4. Creating specialized _visit implementations for each node type based on the original
       visit_* methods in the TraverserVisitor

    This inversion allows us to use the visitor pattern with Mypy AST nodes from outside
    Mypy's compilation unit, avoiding the issues with Node.accept() that would otherwise
    occur when using compiled Mypy.
    """

    _visit_dispatch_src = textwrap.dedent("""
    @functools.singledispatch
    def _visit(node: Node, visitor: TraverserVisitor, /) -> None:
        msg = f"'{type(visitor).__name__}' has no visit method for '{type(node).__name__}'"
        raise NotImplementedError(msg)
    """).strip()

    _visit_method_src = textwrap.dedent("""
    def visit(self, node: Node) -> None:
        _visit(node, self)
    """).strip()

    _enter_method_src = textwrap.dedent("""
    def enter_node(self, node: Node) -> None:
        pass
    """).strip()

    _leave_method_src = textwrap.dedent("""
    def leave_node(self, node: Node) -> None:
        pass
    """).strip()

    _visit_impl_template = textwrap.dedent("""
    @_visit.register
    def _(node: {node_type}, visitor: TraverserVisitor, /) -> None:
        visitor.enter_node(node)
        visitor.{visitor_method}(node)
        visitor.leave_node(node)
    """).strip()

    def __init__(self) -> None:
        self._dispatch_method_cst: libcst.BaseCompoundStatement = libcst.parse_statement(
            self._visit_dispatch_src
        )  # type: ignore[assignment]
        self._visit_impls: list[libcst.BaseCompoundStatement] = []

    def leave_Module(
        self, original_node: libcst.Module, updated_node: libcst.Module
    ) -> libcst.Module:
        del original_node
        body = list(updated_node.body)
        body.append(self._dispatch_method_cst)
        body += self._visit_impls
        return updated_node.with_changes(body=tuple(body))

    def leave_ClassDef(
        self, original_node: libcst.ClassDef, updated_node: libcst.ClassDef
    ) -> (
        libcst.BaseStatement | libcst.FlattenSentinel[libcst.BaseStatement] | libcst.RemovalSentinel
    ):
        del original_node

        body = updated_node.body
        assert isinstance(body, libcst.IndentedBlock)

        i = 0
        for i in range(len(body.body)):
            if (
                isinstance(funcdef := body.body[i], libcst.FunctionDef)
                and funcdef.name.value == "__init__"
            ):
                break

        new_method_sources = [
            self._visit_method_src,
            self._enter_method_src,
            self._leave_method_src,
        ]
        new_methods = tuple(libcst.parse_statement(src) for src in new_method_sources)
        new_body = tuple(body.body[: i + 1]) + new_methods + tuple(body.body[i + 1 :])

        return updated_node.with_changes(body=body.with_changes(body=new_body))

    def leave_FunctionDef(
        self, original_node: libcst.FunctionDef, updated_node: libcst.FunctionDef
    ) -> (
        libcst.BaseStatement | libcst.FlattenSentinel[libcst.BaseStatement] | libcst.RemovalSentinel
    ):
        del original_node
        if not updated_node.name.value.startswith("visit_"):
            return updated_node

        node_annotation = updated_node.params.posonly_params[1].annotation
        assert node_annotation is not None
        visit_impl = libcst.helpers.parse_template_statement(
            self._visit_impl_template,
            node_type=node_annotation,
            visitor_method=updated_node.name,
        )
        assert isinstance(visit_impl, libcst.FunctionDef)
        self._visit_impls.append(visit_impl)

        return updated_node

    def leave_Call(
        self, original_node: libcst.Call, updated_node: libcst.Call
    ) -> libcst.BaseExpression:
        del original_node

        func = updated_node.func
        if not isinstance(func, libcst.Attribute):
            return updated_node

        if func.attr.value != "accept":
            return updated_node

        return libcst.helpers.parse_template_expression("_visit({node}, self)", node=func.value)


class _InsertImports(libcst.CSTTransformer):
    """Simple transformer for introducing new imports.

    Inserts new imports after the last `from __future__` import and before all
    other imports. This results in functionally correct code. A formatter may re-order
    imports at a later stage.
    """

    def __init__(self, imports: Sequence[libcst.Import | libcst.ImportFrom]) -> None:
        self._imports = tuple(imports)

    def leave_Module(
        self, original_node: libcst.Module, updated_node: libcst.Module
    ) -> libcst.Module:
        del original_node

        idx = -1
        for i, statement in enumerate(updated_node.body):
            if not isinstance(statement, libcst.SimpleStatementLine):
                continue
            match statement.body[0]:
                case libcst.Import():
                    if idx == -1:
                        idx = i
                case libcst.ImportFrom(module=libcst.Name("__future__")):
                    idx = i
        idx += 1

        body = updated_node.body
        new_body = tuple(body[:idx]) + self._imports + tuple(body[idx:])
        return updated_node.with_changes(body=new_body)


if __name__ == "__main__":
    main()
