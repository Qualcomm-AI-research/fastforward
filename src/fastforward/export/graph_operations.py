# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear
"""
!!! experimental
    Export is an experimental feature and is currently under active development.
    Please expect API changes. We encourage you to file bug reports if you run into any problems.

"""  # noqa: D205, D212

import collections
import logging
import re

import torch

from fastforward.export._export_schemas import QuantParametersDict

QUANTIZATION_ENCODINGS_NODE_META_KEY: str = "quantization_encodings"


logger = logging.getLogger()


def propagate_encodings(
    exported_program: torch.export.exported_program.ExportedProgram,
    quantization_parameter_dict: dict[str, QuantParametersDict],
) -> dict[str, QuantParametersDict]:
    """Propagate encodings through a dynamo graph.

    The nodes from which the propagation should start from are given from the `quantization_parameter_dict`.
    Then the graph from `exported_program` is traversed in two directions, 1) from starting node to its children,
    and 2) from starting node to its parents.

    Args:
        exported_program: The output of a `torch.export.export` method, which contains the
            underlying graph.
        quantization_parameter_dict: The dictionary of quantization encodings (in the structure
            generated by the `LogQuantizationParameters` visitor class).

    Returns:
        A dictionary of operations and their corresponding quantization encodings.
    """
    dynamo_graph: torch.fx.graph.Graph = exported_program.graph
    graph_nodes: dict[str, torch.fx.node.Node] = {node.name: node for node in dynamo_graph.nodes}
    input_spec_to_type: dict[str, torch.export.graph_signature.InputKind] = {
        input_spec.arg.name: input_spec.kind
        for input_spec in exported_program.graph_signature.input_specs
    }

    for node_name in quantization_parameter_dict:
        node, encodings = _get_node_and_encodings_from_name(
            node_name, graph_nodes, quantization_parameter_dict
        )
        if node is not None and encodings is not None:
            _propagate_to_children(node, encodings)

    for node_name in quantization_parameter_dict:
        node, encodings = _get_node_and_encodings_from_name(
            node_name, graph_nodes, quantization_parameter_dict
        )
        if node is not None and encodings is not None:
            _propagate_to_parents(node, encodings)

    propagated_encodings = {}

    for node_name, node in graph_nodes.items():
        quantization_parameters = node.meta.pop(QUANTIZATION_ENCODINGS_NODE_META_KEY, None)
        if quantization_parameters is not None and not _is_node_parameter_node(
            node, input_spec_to_type
        ):
            propagated_encodings[node_name] = quantization_parameters

    return propagated_encodings


def _get_node_and_encodings_from_name(
    name: str,
    graph_nodes: dict[str, torch.fx.node.Node],
    quantization_parameter_dict: dict[str, QuantParametersDict],
) -> tuple[torch.fx.node.Node | None, QuantParametersDict | None]:
    """Retrieve the node object and encodings given a potential node name.

    Operation to retrieve the node and encodings from a given node name, based on whether
    this is presented as a node on the graph, and encodings associated with it on the quantization
    logs. NB: The parameter nodes in the graph have a different name structure to signify them
    as parameters, than how they appear in the torch model. For example, say there is a weight
    parameter on the first linear layer of a model. This would usually appear as "fc1.weight". However,
    the node name for this is `p_fc1_weight`. For this reason we have some additional logic to convert
    a potential node name to the expected graph node name.

    Args:
        name: The name of the node to look up. This is meant to follow the naming paradigm of the nodes
            in the quantization logs.
        graph_nodes: A dictionary associating node names with node objects.
        quantization_parameter_dict: A dictionary associating node names with quantization encodings.

    Returns:
        The node object and its corresponding parameters.
    """
    node = graph_nodes.get(name)
    encodings = quantization_parameter_dict.get(name)
    if node is None:
        potential_pattern = name.replace(".", "_")
        node_name = next(
            (node for node in graph_nodes if re.search(potential_pattern, node, re.IGNORECASE)),
            None,
        )
        if node_name is None:
            msg = f"Regex search did not find a name matching the node name: {name}. "
            msg += "Encodings will not be propagated from this node."
            logger.warning(msg)
        else:
            node = graph_nodes.get(node_name)
            encodings = quantization_parameter_dict.get(name)
    return (node, encodings)


def _propagate_to_children(
    start_node: torch.fx.node.Node, start_node_encodings: QuantParametersDict
) -> None:
    """Propagation of encodings parameters from a starting node to its children.

    Given a node and its corresponding encodings, propagate the encodings through its
    children given the following conditions:

        1) The child should not have been already visited, ie it has not already been assigned quantization encodings.
        2) The encodings can only be propagated from parent to child, if the child is a view-type operation.

    Args:
        start_node: The node object to start traversing from.
        start_node_encodings: The corresponding encodings to the `start_node`.
    """
    _assign_quantization_encodings_to_node(start_node, start_node_encodings)
    queue = collections.deque([start_node])

    while queue:
        curr_node = queue.popleft()
        child_nodes = [child for child in curr_node.users]

        for child_node in child_nodes:
            is_child_visited = child_node.meta.get(QUANTIZATION_ENCODINGS_NODE_META_KEY) is not None
            if not is_child_visited and _is_node_view_op(child_node):
                queue.append(child_node)
                _assign_quantization_encodings_to_node(child_node, start_node_encodings)


def _propagate_to_parents(
    start_node: torch.fx.node.Node, start_node_encodings: QuantParametersDict
) -> None:
    """Propagation of encodings parameters from a starting node to its parents.

    Given a node and its corresponding encodings, propagate the encodings through its parents
    givent the following conditions:

        1) The encodings are propagated if the starting node is a view-type operation. If this
            is not the case the traversal stops at the starting node.
        2) In the case the parent already has quantization encodings then the encodings are not
            propagated and traversal stops.
        3) In the case the parent is a view operation with no encodings attached to it, the
            propagation continues until we reach a non-view-type operation with no defined encodings.

    Args:
        start_node: The node object to start traversing from.
        start_node_encodings: The corresponding encodings to the `start_node`.
    """
    _assign_quantization_encodings_to_node(start_node, start_node_encodings)
    if not _is_node_view_op(start_node):
        return

    queue = collections.deque([start_node])

    while queue:
        curr_node = queue.popleft()
        parent_nodes = curr_node.all_input_nodes

        for parent_node in parent_nodes:
            is_parent_visited = (
                parent_node.meta.get(QUANTIZATION_ENCODINGS_NODE_META_KEY) is not None
            )
            if not is_parent_visited:
                _assign_quantization_encodings_to_node(parent_node, start_node_encodings)
                if _is_node_view_op(parent_node):
                    queue.append(parent_node)


def _assign_quantization_encodings_to_node(
    node: torch.fx.node.Node, node_encodings: QuantParametersDict
) -> None:
    """Way of marking a node as being visited, and storing quantization parameters in its `meta` dictionary.

    Args:
        node: The node object to which encodings will be assigned.
        node_encodings: The encodings to be assigned to the `node` object.
    """
    node.meta[QUANTIZATION_ENCODINGS_NODE_META_KEY] = node_encodings


def _is_node_parameter_node(
    node: torch.fx.node.Node, input_spec_to_type: dict[str, torch.export.graph_signature.InputKind]
) -> bool:
    """Checks if node is mapped to a model input parameter.

    Args:
        node: The node object to check
        input_spec_to_type: A dictionary associating node name to input kind (meaning
            if the node is associated with an input/parameter/buffer to the graph)

    Returns:
        A boolean of whether the node is a parameter node.
    """
    return input_spec_to_type.get(node.name) is not None


def _is_node_view_op(node: torch.fx.node.Node) -> bool:
    """Check if a node is a view-type operation.

    Args:
        node: The node that needs to be checked.

    Returns:
        A boolean of whether the node is a view-type operation or not.
    """
    if isinstance(node.target, torch._ops.OpOverload):
        return node.target.is_view
    return False
